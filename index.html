<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Planta de Cidade em Three.js</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
    <script src="https://unpkg.com/three@0.87.1/build/three.js"></script>
    <script src="https://unpkg.com/three@0.87.1/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.87.1/examples/js/loaders/GLTFLoader.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script>

        var object
        var mouse = new THREE.Vector2()
        var raycaster = new THREE.Raycaster()
        var offset = new THREE.Vector3()
        var isDragging = false
        const buildings = []

        // Cria a cena
        const scene = new THREE.Scene()

        let zoomCam = 10

        // Cria a câmera
        const camera = new THREE.PerspectiveCamera(zoomCam, window.innerWidth / window.innerHeight, 0.1, 1000)

        // camera.position.set(ver de lado, altura, distancia de frente)
        camera.position.set(40, 40, 40)

        let downCam = 0
        let rigthCam = 6
        let leftCam = 5
        camera.lookAt(leftCam, downCam, rigthCam)

        // Cria o renderizador
        const renderer = new THREE.WebGLRenderer()
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)

        // Função para ajustar o zoom da câmera com base na rolagem do mouse
        function ajustarZoomComScroll (event) {
            // Verifica a direção da rolagem do mouse
            const delta = Math.sign(event.deltaY) // -1 para rolagem para cima, 1 para rolagem para baixo

            // Ajusta o fator de zoom conforme necessário
            const zoomFactor = 0.5

            // Atualiza o valor do zoom da câmera
            zoomCam -= delta * zoomFactor

            // Limita o zoom dentro do intervalo desejado
            zoomCam = Math.max(0.5, zoomCam) // Zoom mínimo
            zoomCam = Math.min(1.5, zoomCam) // Zoom máximo

            // Atualiza a câmera
            camera.zoom = zoomCam
            camera.updateProjectionMatrix()
        }

        // Adiciona o evento de rolagem do mouse à janela
        window.addEventListener("wheel", ajustarZoomComScroll, false)

        // ------------ Adicionando IMagem --------------------/

        function createImage (imgPath) {
            // Cria um objeto de geometria para o plano
            const planeGeometrys = new THREE.PlaneGeometry(6, 4.5)

            // Cria um material com textura para o plano
            const textureLoaders = new THREE.TextureLoader()
            const texture = textureLoaders.load(imgPath)
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true })

            // Cria o objeto de malha para o plano
            const planeMesh = new THREE.Mesh(planeGeometrys, material)

            // Define a posição e rotação do plano
            planeMesh.position.set(9, 5, 9)
            planeMesh.rotation.x = -Math.PI / 50 // Rotaciona o plano para ficar na horizontal
            planeMesh.rotation.y = 2200
            // Adiciona o plano à cena
            scene.add(planeMesh)
        }
        // createImage('./img/torre.png')
        createImage('./img/City_start_humanEDITADA.png')

        // Função para aumentar o valor com a rolagem da bolinha do mouse
        function aumentarValorComScroll (event) {
            // Verifica a direção da rolagem do mouse
            const delta = Math.sign(event.deltaY) // -1 para rolagem para cima, 1 para rolagem para baixo

            // Ajusta a quantidade de incremento/diminuição do valor conforme necessário
            const incremento = 1

            // Atualiza o valor com base na direção da rolagem
            if (delta === -1) {
                valor += incremento
            } else if (delta === 1) {
                valor -= incremento
            }

            // Exemplo: exibe o valor atualizado no console
            console.log("Valor atual:", valor)
        }

        // Exemplo de uso:
        let valor = 0

        // Adiciona o evento de rolagem do mouse ao elemento desejado (por exemplo, o documento)
        document.addEventListener("wheel", aumentarValorComScroll)


        // ------------------------ Criando Textura Predios -------------/

        function createBuildings () {
            // Cria o objeto de geometria para o prédio
            const buildingGeometry = new THREE.BoxGeometry(1.5, 3, 1.5)

            // Cria o material com textura para o prédio
            const textureLoader = new THREE.TextureLoader()
            const buildingTexture = textureLoader.load('./img/teste.gif')
            const buildingMaterial = new THREE.MeshPhongMaterial({ map: buildingTexture })

            // Sem textura, com cor simples
            // const buildingMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide })

            // Cria o objeto de malha para o prédio
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial)

            // ------------------------ Cria um Prédio ----------------------//
            // Define a posição do prédio
            building.position.x = 1.1 // aumente 1.5
            building.position.z = 1 // aumente 1.5

            // Define a altura do prédio
            building.scale.y = 0.1

            // Adiciona o prédio ao array de prédios
            buildings.push(building)

            // Adiciona o prédio à cena
            scene.add(building)
        }
        createBuildings()

        //  ------------------- Função para lidar com o clique na cena
        function onDocumentClick (event) {
            // Normaliza as coordenadas do clique
            const mouse = new THREE.Vector2()
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

            // Define o raio de seleção a partir da posição do clique
            const raycaster = new THREE.Raycaster()
            raycaster.setFromCamera(mouse, camera)

            // Verifica a interseção entre o raio e os prédios
            const intersects = raycaster.intersectObjects(buildings)

            // Verifica se ocorreu uma interseção
            if (intersects.length > 0) {
                alert("Prédio clicado!")
                // Execute a ação desejada para o prédio clicado
            }
        }

        // Adiciona o evento de clique ao elemento da tela
        document.addEventListener('click', onDocumentClick, false)

        // ------------------------ Cria 3 Predios ----------------------//
        // Cria os 3 elementos conforme o numero de limite no for
        // for (let index = 0; index < 3; index++) {
        //     // Cria o objeto de malha para o prédio
        //     const building = new THREE.Mesh(buildingGeometry, buildingMaterial)

        //     // Define a posição do prédio
        //     building.position.x = index
        //     building.position.z = index

        //     // Define a altura do prédio
        //     building.scale.y = 2

        //     // Adiciona o prédio ao array de prédios
        //     buildings.push(building)

        //     // Adiciona o prédio à cena
        //     scene.add(building)
        // }

        // ----------------------- Cria Matriz chão ----------------//

        function createMatriz () {
            // Cria a geometria do plano
            const planeGeometry = new THREE.PlaneGeometry(25, 25)

            // Cria a textura do chão com imagem de grama
            const groundTexture = new THREE.TextureLoader().load('./img/grama.png')
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping
            // Quantas imagens são carregadas
            groundTexture.repeat.set(25, 25)


            // Cria o material do chão
            const groundMaterial = new THREE.MeshBasicMaterial({ map: groundTexture })
            // Cria o objeto de malha para o chão
            const ground = new THREE.Mesh(planeGeometry, groundMaterial)
            // Rotaciona o chão para ficar paralelo ao eixo x
            ground.rotation.x = -Math.PI / 2

            // Posiciona o chão abaixo dos prédios
            ground.position.y = -3
            // Adiciona o chão à cena
            scene.add(ground)

            // Cria a luz ambiente
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
            scene.add(ambientLight)

            // Cria a luz direcional
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5)
            directionalLight.position.set(0, 1, 0)
            scene.add(directionalLight)

        }

        createMatriz()

        // Anima a cena
        function animate () {
            requestAnimationFrame(animate)

            // Gira os prédios em torno do eixo y
            // buildings.forEach(building => {
            //     building.rotation.y += 0.01
            // })

            renderer.render(scene, camera)
        }
        animate()

    </script>
</body>

</html>
